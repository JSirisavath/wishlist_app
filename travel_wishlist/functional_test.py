from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.common.by import By
from selenium.webdriver.support import expected_conditions as EC
from selenium import webdriver
from selenium.webdriver.chrome.webdriver import WebDriver

from django.test import LiveServerTestCase


class TitleTest(LiveServerTestCase):
    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.selenium = WebDriver()
        # Need to wait for browser page to load and then have code run after 10 seconds
        cls.selenium.implicitly_wait(10)

    @classmethod
    def tearDownClass(cls):
        cls.selenium.quit()
        super().tearDownClass()

    def test_title_on_home_page(self):
        self.selenium.get(self.live_server_url)
        self.assertIn('Travel Wishlist', self.selenium.title)


class AddPlacesTest(LiveServerTestCase):
    fixtures = ['test_places']

    @classmethod
    def setUpClass(cls):
        super().setUpClass()
        cls.selenium = WebDriver()
        # Need to wait for browser page to load and then have code run after 10 seconds
        cls.selenium.implicitly_wait(10)

    @classmethod
    def tearDownClass(cls):
        cls.selenium.quit()
        super().tearDownClass()

    def test_add_new_place(self):

        # selenium is practically your testing browser, and how we test each component within the browser is by targeting that element based on their id name. We can essentially "manipulate" the html components and use them for tests and or send data
        self.selenium.get(self.live_server_url)


# Error functional_test.py", line 44, in test_add_new_place
#     input_name = self.selenium.find_element_by_id('id_name')
#                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
# AttributeError: 'WebDriver' object has no attribute 'find_element_by_id'

        input_name = self.selenium.find_element_by_id('id_name')

        input_name.send_keys('Denver')

        add_button = self.selenium.find_element_by_id('add-new-place')

        add_button.click()  # Basically submit the add-button with data

        # The pk after the dummy test place, and since the pk are auto increment, the next is 5
        denver = self.selenium.find_element_by_id('place-name-5')

        # Checking if the word Denver matches with the text denver value element from the html
        self.assertEqual('Denver', denver.text)

        self.assertIn('Denver', self.selenium.page_source)
        self.assertIn('New York', self.selenium.page_source)
        self.assertIn('Tokyo', self.selenium.page_source)


# Original REPO of the functional test
# import selenium


# class TitleTest(LiveServerTestCase):

#     fixtures = ['test_users']

#     def setUp(self):

#         self.browser = webdriver.Firefox()  # Change to .Chrome() if using Chrome
#         self.browser.implicitly_wait(3)

#         # expect to be redirected to login page
#         self.browser.get(self.live_server_url + '/admin')
#         self.browser.find_element_by_id('id_username').send_keys('alice')
#         self.browser.find_element_by_id('id_password').send_keys('qwertyuiop')
#         self.browser.find_element_by_css_selector(
#             'input[type="submit"]').click()

#     def tearDown(self):
#         self.browser.quit()

#     def test_title_shown_on_home_page(self):
#         self.browser.get(self.live_server_url)   # get site homepage
#         self.assertIn(self.browser.title, 'Travel Wishlist')


# class AddEditPlacesTests(LiveServerTestCase):

#     fixtures = ['test_users', 'test_places']

#     def setUp(self):
#         self.browser = webdriver.Firefox()
#         self.browser.implicitly_wait(3)

#         # expect to be redirected to login page
#         self.browser.get(self.live_server_url + '/admin')
#         self.browser.find_element_by_id('id_username').send_keys('alice')
#         self.browser.find_element_by_id('id_password').send_keys('qwertyuiop')
#         self.browser.find_element_by_css_selector(
#             'input[type="submit"]').click()

#     def tearDown(self):
#         self.browser.quit()

#     def test_add_new_place(self):

#         self.browser.get(self.live_server_url)   # Load home page
#         # find input text box. id was generated by Django forms
#         input_name = self.browser.find_element_by_id('id_name')
#         input_name.send_keys('Denver')  # Enter place name
#         add_button = self.browser.find_element_by_id(
#             'add-new-place')  # Find the add button
#         add_button.click()      # And click it

#         # Got to make this test code wait for the server to process the request and for page to reload
#         # Wait for new element to appear on page
#         wait_for_denver = self.browser.find_element_by_id('place-name-7')

#         # Assert wishlist places from test_places are on page
#         self.assertIn('San Francisco', self.browser.page_source)
#         self.assertIn('New York', self.browser.page_source)

#         # And the new place too
#         self.assertIn('Denver', self.browser.page_source)

#     def test_mark_place_as_visited(self):

#         self.browser.get(self.live_server_url)  # Load home page

#         # find visited button. It will have the id visited_pk
#         # Where pk = primary key of item. This was configured in the template
#         # In this test, mark New York, pk=2 visited
#         visited_button = self.browser.find_element_by_id('visited-button-2')

#         # new_york = self.browser.find_element_by_id('place-name-2')  # find the place name text

#         visited_button.click()  # click button

#         # But now page has to reload. How to get Selenium to wait,
#         # And to realize it's a new page, so refresh it's
#         # knowledge of the elements on it?
#         # Can use an Explicit Wait for a particular condition - in this case, the
#         # absence of an element with id = place-name-2

#         wait = WebDriverWait(self.browser, 3)
#         ny_has_gone = wait.until(
#             EC.invisibility_of_element_located((By.ID, 'place-name-2')))

#         # Assert San Francisco is still on page
#         self.assertIn('San Francisco', self.browser.page_source)

#         # But New York is not
#         self.assertNotIn('New York', self.browser.page_source)

#         # Load visited page
#         self.browser.get(self.live_server_url + '/visited')

#         # New York should now be on the visited page
#         self.assertIn('New York', self.browser.page_source)

#         # As well as our other visited places

#         self.assertIn('Tokyo', self.browser.page_source)
#         self.assertIn('Moab', self.browser.page_source)


# class PageContentTests(LiveServerTestCase):

#     fixtures = ['test_users', 'test_places']

#     def setUp(self):
#         self.browser = webdriver.Firefox()
#         self.browser.implicitly_wait(3)

#         # expect to be redirected to login page
#         self.browser.get(self.live_server_url + '/admin')
#         self.browser.find_element_by_id('id_username').send_keys('alice')
#         self.browser.find_element_by_id('id_password').send_keys('qwertyuiop')
#         self.browser.find_element_by_css_selector(
#             'input[type="submit"]').click()

#     def tearDown(self):
#         self.browser.quit()

#     def test_get_home_page_list_of_places(self):

#         self.browser.get(self.live_server_url)

#         self.assertIn('San Francisco', self.browser.page_source)
#         self.assertIn('New York', self.browser.page_source)

#         self.assertNotIn('Tokyo', self.browser.page_source)
#         self.assertNotIn('Moab', self.browser.page_source)

#     def test_get_list_of_visited_places(self):

#         self.browser.get(self.live_server_url + '/visited')

#         self.assertIn('Tokyo', self.browser.page_source)
#         self.assertIn('Moab', self.browser.page_source)

#         self.assertNotIn('San Francisco', self.browser.page_source)
#         self.assertNotIn('New York', self.browser.page_source)
